<script src="./scripts/main.js" type="module"(используется дл того, чтобы можно было в этом файле использовать ключевые слова "импорт" и "экспорт"? defer - скрипт запускается после полной загрузки
DOM дерева, а именно - когда будут готовы элементы внутри Body. Нам нужна гарантия для скрипта, что эти элементы в Body присутствуют></script>

Когда в будущем понадобится какой-либо файл scss проекта понадобится sass функция, миксин или медиа запрос, то мы будем обращаться к _index.scss, в котором
В чём смысл разделения?
@use — ты используешь чужой SCSS.
@forward — ты переадресовываешь SCSS другим, как будто строишь модульную структуру.

Для работы с scss нужно установить препроцессор стилей. Изначально можно препроцессор установить глобально на ПК и затем настроить команду запуска в VScode
Для WS можно использовать встроенный компилятор-преобразователь в css формат

Но более универсальный способ - через NodeJS

Node.js — это программа, которая позволяет запускать JavaScript не в браузере, а на компьютере или сервере. Он умеет:
Читать/записывать файлы на диск
Обрабатывать запросы от пользователей (как backend)
Работать с базами данных
Запускать другие программы

Node.js может запускать инструменты, которые преобразуют SCSS → CSS.

С Node.js можно инициализировать пакетный менеджер npm. Для этого в терминале ввести "npm init". Можно после этого все скипать просто на энтер, а после консоли появится файл package.json
В этом файле все параметры нашего проекта. Здесь же перечисляются все библиотеки, которые необходимы для корректной работы. У нас библиотекой будет sass

Для этого в консоли вводим: npm install sass --save-dev или короче npm i sass -D

Для этого курса нужна конкретная версия, поскольку записан курс был на старую версию. Версия 1.89.1 у меня, нужна 1.80.6 Для этого нужно ввести npm i sass@1.80.6 -D

Для комфортной работы с препроцессором в документе pakage.json в поле скрипт добавим "sass-watch": "sass --watch ." для автоматического отслеживания всех scss файлов в рамках текущего проекта
и их компиляция в css

//в файле package.json - sass-watch = препроцессор автоматически компилирует изменяемые scss файлы в css
в .json НЕТ возможности вставки комментариев, т.к. он д.б. легко парсируемым (разбивался на части) и не содержал лишней информации, которая может повлиять на анализ данных

для запуска sass-watch и проверки -> npm run sass-watch

После этого под файлом main.scss создается файл main.css - стандартные стили и main.css.map - этот документ указывает браузеру на стили в scss файле. Т.е. если изменение тега p в css коде находится на
100 строке, то мы заебемся искать в scss, а карта как раз указывает браузеру (видно в просмотре кода) на какой строке scss находится изменение

_показывает препроцессору, что не нужно файлы эти конвертировать в css

В файле _normalize - нужна нормализация стилей @import '@a1rth/css-normalize/index.css'; Это вариант с канала "Александр Ламков"
Или по ссылке: "https://raw.githubusercontent.com/aleksanderlamkov/css-normalize/main/index.css"

Файлы .ttf считаются устаревшими, а они и скачиваются с гугла. Поэтому нужно их переформатировать на сайте: https://transfonter.org/
woff2 - самый современный

После шрифтов - миксины это повторяемый блок кода, который ты можешь вставлять в разные места, как по шаблону. Они - не переменные, ведь содержат больше 1 строки, они скорее функции, поскольку содержат блоки стилей

Доп. задание - просмотр видео пиксели vs rem

sass и scss одно и то же, но с разным синтаксисом, sass считается устаревшим

В файле _media.scss миксины медиазапросов, чтобы было удобней выполнять адаптив приложения

./ - искать файл в текущей папке
../ - искать в папке на уровень выше

число.98px — это тонкая защита от глюков в медиазапросах, когда экраны находятся прямо на грани между брейкпоинтами.
Это общепринятый практический хак — особенно полезен в продакшн-вёрстке.

@content - передаем контент в миксин при его вызове

_variables создаем сначала названия цветов внутри

в функции fluid-text в основном указывается самый большой размер - десктоп и самый маленький - телефон. прим. fluid-text(48,14)

Разметка пишется по БЭМ методологии. Сущности - БЭМ блок, БЭМ элемент, БЭМ модификатор. Прим:
Header - БЭМ блок, 2 дочерних элемента - header__promo, header__body


Элемент alt в теге img лучше оставлять пустым, иначе скринридер начнет читать url ссылки

Почему размер шрифта 12px считается плохим тоном даже на мобильной версии? Разработчик все равно поставил 14

laptop - ставить 1440 px ширину

если мы используем путь '../helpers' as *; То препроцессор не может дать гарантии, что там есть
нужные миксины и функции, поэтому может выдавать ошибку якобы, но при этом все работает хорошо
чтобы не было такой ошибки нужно указывать так:
@use '../helpers/functions' as f; Указываем, что в этом документе нужно найти функции, а затем, в самом
документе нужно указывать f.название функции
@use '../helpers/mixins' as m; То же самое, как с функциями m.название

Хороший тон - делать кликабельную область на кнопке минимум 44 на 44 px, в макете всего 34 на 34, поэтому в конце globals мы добавили код,
Комментарии под ним

Принцип учителя в JS - не обращается к элементам по ID и по CSS классам. Идентификаторы должны быть уникальными в рамках страницы,
а классы предназначены для стилизации

Добавляем data атрибуты для мест где нужен будет JS. Прим: data-js-header

Что такое в программировании: Волшебные строки и магические числа?


body {
  display: flex;
  flex-direction: column;
}

main {
  flex-grow: 1; //Растягивается на максимально доступную высоту. Фуутер так будет всегда прижат к низу страницы
}

Утилитарный класс, класс делающий ровно одну вещь. Прим:
.text-center - делает только одно - выравнивает текст по центру
Само слово означает - практичный, функциональный

<div class="footer__soc1als soc1als"></div> цифра 1 в названии - НЕ ошибка, это нужно, чтобы блокировщики
рекламы не скрывали этот элемент

target="_blank" -- ссылки будут открываться в новой вкладке браузера, пригодилось в футере для перехода на другие
соц. сети

<date datetime="2024">2024</date> для соблюдения семантики

доп. уроки - когда использовать grid, когда flex?

Под шапкой секцию большую с большим количеством важной инфы называют hero

section тег выделяет элемент на странице, говоря, что это секция определенная, типо главы в книге.

Так, секции с доступными заголовки помогают пользователям со скринридером. Для этого в заголовке добавляем id="название"
А предыдущему атрибуту section атрибут aria-labelledby="ID заголовка"

dl. - список-описание, в hero__metrics больше подошел по смыслу?

Сначала скринридер будет читать metrics__value h3, затем metrics__key, используя flex-direction: column-reverse

Что такое loading="lazy"? "Не загружай этот элемент, пока он не попадёт в область видимости (или не приблизится к ней)"
Чтобы ускорить загрузку сайта и уменьшить потребление трафика.

Почему в resources-preview__title мы сделали тегом p и дали класс h5, а не тег h5 просто? Мы бы нарушили структуру заголовков
у нас есть только h1 и нету h2,3,4, поэтому не стоит делать заголовок тегом, лучше классом, чтобы не нарушать структуру

Можно создавать БЭМ подблоки, по примеру hero__advantages-list, а внутри него отдельно advantage-card, чтобы не сильно нагружать блоки

Сейчас в ссылки можно вкладывать в любые заголовки, все норм. Главное, чтобы внутри ссылки не было другие интерактивных элементов:
Кнопки, поля ввода, ссылки и т.д.

  //По идее можно написать просто margin-bottom, но конструкция с last-child делается для того, чтобы в будущем,
    //если элемент станет вдруг последним в списке, то margin ему будет вовсе не нужен
    &:not(:last-child) {
      margin-bottom: rem(30);
    }
    Все margin-bottom и margin-right автор рекомендует писать в такой конструкции

причина создания переменной - --personImageSize, в будущем ещё встретятся подобные изображения и размер их будет 50px, чтобы в будущем обращаться не к элементу
.team__person, а просто к БЭМ блоку - team, чтобы переопределить значение переменной

mixin abs-center позиционирует абсолютом в середине по обеим осям

.full-vw-line в utils - сложная формула для моего понимания пока что, но штука очень полезная, позволяет отрисовать линию за пределами контентного контейнера через псевдоэлементы
И происходит это так, что линия растягивается ровно до конца страницы и из-за неё не появится горизонтального скролла

export изображения в 4x для увеличения разрешения? Чтобы не смотрелась на tablet слишком убого

Секцию Features решили делать с помощью типового структурного шаблона, так как такая секция встретится ещё не раз

Важная заметка, тег header стоит использовать не только в самой шапке страницы вверху, можно также использовать в шапках других блоков

<div class="section__header-info"></div> по идее не нужна в секции section, но пригодится в других, поэтому решили вставить сразу
Чтобы не пришлось кастылять, заранее продумываем структуру для каждой секции

<section class="section" aria-labelledby="features-title">
<h2 class="section__title" id="features-title">FutureTech Features</h2>
Ты знаешь, что это, для скринридеров. Просто, чтобы не забыть оформление

компонент list делаем, это обычный список, у всех элементов кроме последнего должна быть 1px нижняя рамка

card__grid--2-cols класс показывает, что разметка элемента гридом с сеткой 2-колоночной

tile - плитка, пригодится ещё не раз, сделали утилитарным классом

Почему иногда мы используем миксин fluid, указывая размеры на десктопе и мобилке, чтобы размер уменьшался, а иногда просто используем rem значение?

Аааа, мы НЕ можем использовать fluid, если на laptop размер УЖЕ такой, как на мобилке. Прим: width: на десктопе 100, на мобилке 50,
Можно было бы использовать fluid, но нет, ведь laptop тоже имеет размер 50

В чем отличие свойств gap и row-gap?

Когда стоит использовать подход mobile-first? Следуя курсу, сначала мы делаем десктоп версию, а когда уже перестраиваем сетку под мобилки/лэптоп, то меняем код
делаем медиа запрос tablet-above, в него вставляем вырезанный код. Тогда у нас при расширении больше 1023px, то есть 1024 выстраивается код, который мы писали
изначально, а на то, что будет по размеру меньше мы напишем над медиа запросом... Или как?

Правила семантики - понятно, более менее. А что такое правила аксессибилити?

Создаем в секции отдельный БЭМ блок - tabs и там сразу пишем data-js-tabs, это будут переключаемые окошки и нам нужно сразу добавить data тег для JS кода

Для tabs buttons для обеспечения доступности важно добавить аттрибут role="tablist" - зачем?

type="button" обязателен для всех кнопок

<button
              class="tabs__button"
              id="tab-2"
              type="button"
              role="tab"
              aria-controls="tabpanel-2"
              data-js-tabs-button
              aria-selected="false"
              tabindex="-1"
            >
 Нужно разобрать все элементы этой кнопки с GPT, для дебилов)

 <div
             class="tabs__content"
             id="tabpanel-1"
             aria-labelledby="tab-1"
           >
Логика такая, тут мы через tab-1 обращаемся к шапке и говорим кнопке, что она "содержит" этот контент
А сама кнопка видит, что этот контент привязан к ней через id tabpanel
Т.е. кнопка с названием all будет управлять этим div'ом, а через aria-labelledby ссылаемся на ID кнопки с текстом All, что этот контент
Озаглавлен, подписан текстовым содержимым той кнопки

tabindex="0" - важно для тех, кто привык навигировать сайт с клавиатуры и пользователям скринридера. Элемент может быть фокусирован с клавиатуры.

Зачем использовать тег article?

&:has() - проверяет, есть ли внутри элемента к которому псевдокласс has применен элемент, селектор которого передаем в скобках

Часто автор при верстке элемента сразу чекает его на лэптопе и телефоне, прописывая значения не одним числом, а через fluid

Что такое 1fr в гридах?

Почему в скриптах main написали с маленькой буквы, а другие скрипты с большой?
