<script src="./scripts/main.js" type="module"(используется дл того, чтобы можно было в этом файле использовать ключевые слова "импорт" и "экспорт"? defer - скрипт запускается после полной загрузки
DOM дерева, а именно - когда будут готовы элементы внутри Body. Нам нужна гарантия для скрипта, что эти элементы в Body присутствуют></script>

Когда в будущем понадобится какой-либо файл scss проекта понадобится sass функция, миксин или медиа запрос, то мы будем обращаться к _index.scss, в котором
В чём смысл разделения?
@use — ты используешь чужой SCSS.
@forward — ты переадресовываешь SCSS другим, как будто строишь модульную структуру.

Для работы с scss нужно установить препроцессор стилей. Изначально можно препроцессор установить глобально на ПК и затем настроить команду запуска в VScode
Для WS можно использовать встроенный компилятор-преобразователь в css формат

Но более универсальный способ - через NodeJS

Node.js — это программа, которая позволяет запускать JavaScript не в браузере, а на компьютере или сервере. Он умеет:
Читать/записывать файлы на диск
Обрабатывать запросы от пользователей (как backend)
Работать с базами данных
Запускать другие программы

Node.js может запускать инструменты, которые преобразуют SCSS → CSS.

С Node.js можно инициализировать пакетный менеджер npm. Для этого в терминале ввести "npm init". Можно после этого все скипать просто на энтер, а после консоли появится файл package.json
В этом файле все параметры нашего проекта. Здесь же перечисляются все библиотеки, которые необходимы для корректной работы. У нас библиотекой будет sass

Для этого в консоли вводим: npm install sass --save-dev или короче npm i sass -D

Для этого курса нужна конкретная версия, поскольку записан курс был на старую версию. Версия 1.89.1 у меня, нужна 1.80.6 Для этого нужно ввести npm i sass@1.80.6 -D

Для комфортной работы с препроцессором в документе pakage.json в поле скрипт добавим "sass-watch": "sass --watch ." для автоматического отслеживания всех scss файлов в рамках текущего проекта
и их компиляция в css

//в файле package.json - sass-watch = препроцессор автоматически компилирует изменяемые scss файлы в css
в .json НЕТ возможности вставки комментариев, т.к. он д.б. легко парсируемым (разбивался на части) и не содержал лишней информации, которая может повлиять на анализ данных

для запуска sass-watch и проверки -> npm run sass-watch

После этого под файлом main.scss создается файл main.css - стандартные стили и main.css.map - этот документ указывает браузеру на стили в scss файле. Т.е. если изменение тега p в css коде находится на
100 строке, то мы заебемся искать в scss, а карта как раз указывает браузеру (видно в просмотре кода) на какой строке scss находится изменение

_показывает препроцессору, что не нужно файлы эти конвертировать в css

В файле _normalize - нужна нормализация стилей @import '@a1rth/css-normalize/index.css'; Это вариант с канала "Александр Ламков"
Или по ссылке: "https://raw.githubusercontent.com/aleksanderlamkov/css-normalize/main/index.css"

Файлы .ttf считаются устаревшими, а они и скачиваются с гугла. Поэтому нужно их переформатировать на сайте: https://transfonter.org/
woff2 - самый современный

После шрифтов - миксины это повторяемый блок кода, который ты можешь вставлять в разные места, как по шаблону. Они - не переменные, ведь содержат больше 1 строки, они скорее функции, поскольку содержат блоки стилей

Доп. задание - просмотр видео пиксели vs rem

sass и scss одно и то же, но с разным синтаксисом, sass считается устаревшим

В файле _media.scss миксины медиазапросов, чтобы было удобней выполнять адаптив приложения

./ - искать файл в текущей папке
../ - искать в папке на уровень выше

число.98px — это тонкая защита от глюков в медиазапросах, когда экраны находятся прямо на грани между брейкпоинтами.
Это общепринятый практический хак — особенно полезен в продакшн-вёрстке.

@content - передаем контент в миксин при его вызове

_variables создаем сначала названия цветов внутри

в функции fluid-text в основном указывается самый большой размер - десктоп и самый маленький - телефон. прим. fluid-text(48,14)

Разметка пишется по БЭМ методологии. Сущности - БЭМ блок, БЭМ элемент, БЭМ модификатор. Прим:
Header - БЭМ блок, 2 дочерних элемента - header__promo, header__body


Элемент alt в теге img лучше оставлять пустым, иначе скринридер начнет читать url ссылки

Почему размер шрифта 12px считается плохим тоном даже на мобильной версии? Разработчик все равно поставил 14

laptop - ставить 1440 px ширину

если мы используем путь '../helpers' as *; То препроцессор не может дать гарантии, что там есть
нужные миксины и функции, поэтому может выдавать ошибку якобы, но при этом все работает хорошо
чтобы не было такой ошибки нужно указывать так:
@use '../helpers/functions' as f; Указываем, что в этом документе нужно найти функции, а затем, в самом
документе нужно указывать f.название функции
@use '../helpers/mixins' as m; То же самое, как с функциями m.название

Хороший тон - делать кликабельную область на кнопке минимум 44 на 44 px, в макете всего 34 на 34, поэтому в конце globals мы добавили код,
Комментарии под ним

Принцип учителя в JS - не обращается к элементам по ID и по CSS классам. Идентификаторы должны быть уникальными в рамках страницы,
а классы предназначены для стилизации

Добавляем data атрибуты для мест где нужен будет JS. Прим: data-js-header

Что такое в программировании: Волшебные строки и магические числа?